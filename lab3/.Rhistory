}
myDraws <- RWMSampler( PoiPost, 1000, 5, -solve(OptimResults$hessian), y, xMatrix, mu, Sigma)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
print(length(covar))
currentTheta = rep(0, length(covar))
draws = matrix(0, nrow = n, ncol = length(covar))
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, currentTheta, c*covar)
newProbability <- logPostFunc(currentDraw, ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, -solve(OptimResults$hessian), y, xMatrix, mu, Sigma)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
print(length(covar))
currentTheta = rep(0, dim(covar)[1])
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, currentTheta, c*covar)
newProbability <- logPostFunc(currentDraw, ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, -solve(OptimResults$hessian), y, xMatrix, mu, Sigma)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
print(dim(covar)[1])
currentTheta = rep(0, dim(covar)[1])
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, currentTheta, c*covar)
newProbability <- logPostFunc(currentDraw, ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, -solve(OptimResults$hessian), y, xMatrix, mu, Sigma)
-solve(OptimResults$hessian)
myDraws <- RWMSampler( PoiPost, 1000, 5, solve(OptimResults$hessian), y, xMatrix, mu, Sigma)
myDraws <- RWMSampler( PoiPost, 1000, 5, solve(OptimResults$hessian), y, xMatrix, mu, Sigma)
solve(OptimResults$hessian)
is.positive.definite(solve(OptimResults$hessian))
diag(solve(OptimResults$hessian))
diag(diag(solve(OptimResults$hessian)))
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
betatilde
length(betatilde)
PoiPost <- function(theta,y,X, mu, SigmaGPrior) {
nPara <- length(theta);
print(theta)
linPred <- X%*%theta;
logPoiLik <- sum( linPred*y -exp(linPred) - log(factorial(y)));
if (abs(logPoiLik) == Inf) logPoiLik = -20000; # Likelihood is not finite, stear the optimizer away from here!
logBetaPrior <- dmvnorm(theta, matrix(0,nPara,1), SigmaGPrior, log=TRUE);
return(logPoiLik + logBetaPrior)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
print(dim(covar)[1])
currentTheta = rep(0, dim(covar)[1])
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(t(currentDraw), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
Sigma
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, diag(Sigma))
diag(Sigma)
PoiPost <- function(theta,y,X, mu, SigmaGPrior) {
nPara <- length(theta);
print(theta)
linPred <- X%*%theta;
print(X)
print(SigmaGPrior)
logPoiLik <- sum( linPred*y -exp(linPred) - log(factorial(y)));
if (abs(logPoiLik) == Inf) logPoiLik = -20000; # Likelihood is not finite, stear the optimizer away from here!
logBetaPrior <- dmvnorm(theta, matrix(0,nPara,1), SigmaGPrior, log=TRUE);
return(logPoiLik + logBetaPrior)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, diag(Sigma))
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, t(diag(Sigma)))
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, t(mu), Sigma)
xMatrix = as.matrix(X)
sigmaGPrior = 100*solve((t(xMatrix)%*%xMatrix))
tau = 10
chooseCov <- c(1:9)
covNames <- names(rawData)[2:length(names(rawData))];
xMatrix <- xMatrix[,chooseCov]; # Here we pick out the chosen covariates.
covNames <- covNames[chooseCov];
nPara <- dim(X)[2];
# Setting up the prior
mu <- as.vector(rep(0,nPara)) # Prior mean vector
Sigma <- tau^2*diag(nPara);
PoiPost <- function(theta,y,X, mu, SigmaGPrior) {
nPara <- length(theta);
print(theta)
linPred <- X%*%theta;
print(X)
print(SigmaGPrior)
logPoiLik <- sum( linPred*y -exp(linPred) - log(factorial(y)));
if (abs(logPoiLik) == Inf) logPoiLik = -20000; # Likelihood is not finite, stear the optimizer away from here!
logBetaPrior <- dmvnorm(theta, matrix(0,nPara,1), SigmaGPrior, log=TRUE);
return(logPoiLik + logBetaPrior)
}
initVal <- as.vector(rep(0,dim(X)[2]));
logPost = PoiPost;
OptimResults<-optim(initVal,logPost,gr=NULL,y,xMatrix,mu,Sigma,method=c("BFGS"),control=list(fnscale=-1),hessian=TRUE)
approxPostStd <- sqrt(diag(-solve(OptimResults$hessian)))
names(approxPostStd) <- covNames # Naming the coefficient by covariates
betatilde = OptimResults$par
print("Betatilde: ")
print(betatilde)
print("Jacobiany beta: ")
print(approxPostStd)
xMatrix = as.matrix(X)
sigmaGPrior = 100*solve((t(xMatrix)%*%xMatrix))
tau = 10
chooseCov <- c(1:9)
covNames <- names(rawData)[2:length(names(rawData))];
xMatrix <- xMatrix[,chooseCov]; # Here we pick out the chosen covariates.
covNames <- covNames[chooseCov];
nPara <- dim(X)[2];
# Setting up the prior
mu <- as.vector(rep(0,nPara)) # Prior mean vector
Sigma <- tau^2*diag(nPara);
PoiPost <- function(theta,y,X, mu, SigmaGPrior) {
nPara <- length(theta);
print(theta)
linPred <- X%*%theta;
logPoiLik <- sum( linPred*y -exp(linPred) - log(factorial(y)));
if (abs(logPoiLik) == Inf) logPoiLik = -20000; # Likelihood is not finite, stear the optimizer away from here!
logBetaPrior <- dmvnorm(theta, matrix(0,nPara,1), SigmaGPrior, log=TRUE);
return(logPoiLik + logBetaPrior)
}
initVal <- as.vector(rep(0,dim(X)[2]));
logPost = PoiPost;
OptimResults<-optim(initVal,logPost,gr=NULL,y,xMatrix,mu,Sigma,method=c("BFGS"),control=list(fnscale=-1),hessian=TRUE)
approxPostStd <- sqrt(diag(-solve(OptimResults$hessian)))
names(approxPostStd) <- covNames # Naming the coefficient by covariates
betatilde = OptimResults$par
print("Betatilde: ")
print(betatilde)
print("Jacobiany beta: ")
print(approxPostStd)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
print(dim(covar)[1])
currentTheta = matrix(0, dim(covar)[1], 1)
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(t(currentDraw), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
currentTheta = matrix(0, dim(covar)[1], 1)
print(currentTheta)
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(t(currentDraw), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
xMatrix = as.matrix(X)
sigmaGPrior = 100*solve((t(xMatrix)%*%xMatrix))
tau = 10
chooseCov <- c(1:9)
covNames <- names(rawData)[2:length(names(rawData))];
xMatrix <- xMatrix[,chooseCov]; # Here we pick out the chosen covariates.
covNames <- covNames[chooseCov];
nPara <- dim(X)[2];
# Setting up the prior
mu <- as.vector(rep(0,nPara)) # Prior mean vector
Sigma <- tau^2*diag(nPara);
PoiPost <- function(theta,y,X, mu, SigmaGPrior) {
nPara <- length(theta);
print(theta)
linPred <- X%*%theta;
logPoiLik <- sum( linPred*y -exp(linPred) - log(factorial(y)));
if (abs(logPoiLik) == Inf) logPoiLik = -20000; # Likelihood is not finite, stear the optimizer away from here!
logBetaPrior <- dmvnorm(theta, matrix(0,nPara,1), SigmaGPrior, log=TRUE);
return(logPoiLik + logBetaPrior)
}
initVal <- as.vector(rep(0,dim(X)[2]));
logPost = PoiPost;
OptimResults<-optim(initVal,logPost,gr=NULL,y,xMatrix,mu,Sigma,method=c("BFGS"),control=list(fnscale=-1),hessian=TRUE)
approxPostStd <- sqrt(diag(-solve(OptimResults$hessian)))
names(approxPostStd) <- covNames # Naming the coefficient by covariates
betatilde = OptimResults$par
print("Betatilde: ")
print(betatilde)
print("Jacobiany beta: ")
print(approxPostStd)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
currentTheta = matrix(0, 1, dim(covar)[1])
print(currentTheta)
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(t(currentDraw), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
currentTheta = matrix(0, 1, dim(covar)[1])
print(currentTheta)
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(as.vector(currentDraw)), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
currentTheta = rep(0, dim(covar)[1])
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(as.vector(currentTheta), ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(as.vector(currentDraw)), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
currentTheta = as.vector(rep(0, dim(covar)[1]))
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(as.vector(currentDraw)), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
currentTheta = t(as.vector(rep(0, dim(covar)[1])))
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(as.vector(currentDraw)), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
xMatrix = as.matrix(X)
sigmaGPrior = 100*solve((t(xMatrix)%*%xMatrix))
tau = 10
chooseCov <- c(1:9)
covNames <- names(rawData)[2:length(names(rawData))];
xMatrix <- xMatrix[,chooseCov]; # Here we pick out the chosen covariates.
covNames <- covNames[chooseCov];
nPara <- dim(X)[2];
# Setting up the prior
mu <- as.vector(rep(0,nPara)) # Prior mean vector
Sigma <- tau^2*diag(nPara);
PoiPost <- function(theta,y,X, mu, SigmaGPrior) {
nPara <- length(theta);
print(theta)
linPred <- X%*%theta;
logPoiLik <- sum( linPred*y -exp(linPred) - log(factorial(y)));
if (abs(logPoiLik) == Inf) logPoiLik = -20000; # Likelihood is not finite, stear the optimizer away from here!
logBetaPrior <- dmvnorm(theta, matrix(0,nPara,1), SigmaGPrior, log=TRUE);
return(logPoiLik + logBetaPrior)
}
initVal <- as.vector(rep(0,dim(X)[2]));
logPost = PoiPost;
OptimResults<-optim(initVal,logPost,gr=NULL,y,xMatrix,mu,Sigma,method=c("BFGS"),control=list(fnscale=-1),hessian=TRUE)
approxPostStd <- sqrt(diag(-solve(OptimResults$hessian)))
names(approxPostStd) <- covNames # Naming the coefficient by covariates
betatilde = OptimResults$par
print("Betatilde: ")
print(betatilde)
print("Jacobiany beta: ")
print(approxPostStd)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
currentTheta = as.vector(rep(0, dim(covar)[1]))
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(as.vector(currentDraw)), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
mu
currentTheta
as.matrix(mu)
as.vector(as.matrix(mu))
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
currentTheta = as.vector(rep(0, dim(covar)[1]))
print(currentTheta)
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(as.vector(currentDraw)), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
print(dim(covar)[1])
currentTheta = as.vector(rep(0, dim(covar)[1]))
print(currentTheta)
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(as.vector(currentDraw)), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
clc
clear
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
print(dim(covar)[1])
currentTheta = as.vector(rep(0, dim(covar)[1]))
print(currentTheta)
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(as.vector(currentDraw), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
currentTheta = as.vector(rep(0, dim(covar)[1]))
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(as.vector(currentDraw), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
PoiPost <- function(theta,y,X, mu, SigmaGPrior) {
nPara <- length(theta);
linPred <- X%*%theta;
logPoiLik <- sum( linPred*y -exp(linPred) - log(factorial(y)));
if (abs(logPoiLik) == Inf) logPoiLik = -20000; # Likelihood is not finite, stear the optimizer away from here!
logBetaPrior <- dmvnorm(theta, matrix(0,nPara,1), SigmaGPrior, log=TRUE);
return(logPoiLik + logBetaPrior)
}
RWMSampler <- function(logPostFunc, n,  c, covar,  ...) {
currentTheta = as.vector(rep(0, dim(covar)[1]))
draws = matrix(0, nrow = n, ncol = dim(covar)[1])
oldProbability = logPostFunc(currentTheta, ...)
for(i in 1:n) {
currentDraw <- rmvt(1, mu = currentTheta, S = c*covar)
newProbability <- logPostFunc(as.vector(currentDraw), ...)
alpha = min(1, newProbability/oldProbability)
uniformDraw = runif(1, 0, 1)
if(uniformDraw >= alpha) {
oldProbability = newProbability
currentTheta = currentDraw
}
draws[i,] = currentDraw
}
return(draws)
}
myDraws <- RWMSampler( PoiPost, 1000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
myDraws
hist(myDraws[,1])
print(betatilde)
myDraws <- RWMSampler( PoiPost, 10000, 5, diag(diag(-solve(OptimResults$hessian))), y, xMatrix, mu, Sigma)
hist(myDraws[,1])
hist(myDraws[,2])
hist(myDraws[,3])
hist(myDraws[,4])
hist(myDraws[,5])
hist(myDraws[,6])
hist(myDraws[,7])
hist(myDraws[,1])
hist(myDraws[,7])
hist(myDraws[,6])
hist(myDraws[,8])
hist(myDraws[,9])
